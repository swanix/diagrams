<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Swanix Diagrams Lite</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #2c3e50;
      color: #333;
    }
    
    .xcanvas {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    
    svg {
      width: 100%;
      height: 100%;
    }
    
    .node rect {
      fill: #fff;
      stroke: #ccc;
      stroke-width: 1px;
      rx: 4px;
    }
    
    .node:hover rect {
      stroke: #999;
    }
    
    .label-text {
      font-size: 12px;
      fill: #333;
      text-anchor: middle;
    }
    
    .label-id {
      font-size: 10px;
      fill: #666;
      text-anchor: middle;
    }
    
    .cluster-title {
      font-size: 20px;
      font-weight: bold;
      fill: #333;
      text-anchor: start;
    }
    
    .cluster-bg {
      fill: #f8f9fa;
      stroke: #dee2e6;
      stroke-width: 3px;
      rx: 12px;
      opacity: 0.95;
      transition: all 0.3s ease;
    }
    
    .cluster-bg:hover {
      fill: #e9ecef;
      stroke: #007bff;
      stroke-width: 4px;
      filter: drop-shadow(0 4px 8px rgba(0, 123, 255, 0.3));
    }
    
    .cluster-title {
      font-size: 20px;
      font-weight: bold;
      fill: #333;
      text-anchor: start;
      transition: fill 0.3s ease;
    }
    
    .cluster-title:hover {
      fill: #007bff;
    }
    
    .cluster-container {
      overflow: hidden;
    }
    
    .info-panel {
      position: fixed;
      top: 15px;
      right: 15px;
      background: rgba(33, 33, 33, 0.85);
      border: 1px solid #444;
      border-radius: 6px;
      padding: 10px;
      font-family: monospace;
      font-size: 11px;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      min-width: 150px;
      backdrop-filter: blur(5px);
    }
    
    .info-panel h3 {
      margin: 0 0 8px 0;
      font-size: 12px;
      color: #fff;
      font-weight: normal;
    }
    
    .info-item {
      margin: 5px 0;
      color: #ccc;
    }
    
    .link {
      fill: none;
      stroke: #999;
      stroke-width: 1px;
    }
    
    .material-icons {
      font-family: 'Material Icons';
      font-weight: normal;
      font-style: normal;
      font-size: 48px;
      line-height: 1;
      letter-spacing: normal;
      text-transform: none;
      display: inline-block;
      white-space: nowrap;
      word-wrap: normal;
      direction: ltr;
      -webkit-font-feature-settings: 'liga';
      -webkit-font-smoothing: antialiased;
      fill: #666;
      text-anchor: middle;
    }
    

  </style>
</head>
<body>

  
      <div class="info-panel">
      <h3>Diagrama</h3>
      <div class="info-item">Nodos: <span id="node-count">0</span></div>
      <div class="info-item">Clusters: <span id="cluster-count">0</span></div>
      <div class="info-item">Zoom: <span id="zoom-level">1.00x</span></div>
      <div class="info-item" style="font-size: 10px; color: #999; margin-top: 8px;">
        üí° Clic: zoom ‚Ä¢ Doble clic: reset
      </div>
      <div id="zoom-status" class="info-item" style="font-size: 10px; color: #28a745; margin-top: 3px; display: none;">
        üîç Zoom aplicado
      </div>
    </div>

  <div class="xcanvas">
    <svg id="diagram"></svg>
  </div>

  <script src="https://unpkg.com/d3@7.9.0/dist/d3.min.js"></script>
  <script src="https://unpkg.com/papaparse@5.3.0/papaparse.min.js"></script>

  <script>
    // Variables globales
    let globalTrees = [];
    let globalContainer = null;
    let renderStartTime = 0;
    
    // Lista de √≠conos v√°lidos de Material Icons
    const validMaterialIcons = [
      'person', 'business', 'computer', 'supervisor_account', 'manage_accounts', 
      'code', 'star', 'school', 'settings', 'campaign', 'point_of_sale',
      'account_balance', 'work', 'home', 'search', 'favorite', 'info',
      'warning', 'error', 'check_circle', 'cancel', 'add', 'remove',
      'edit', 'delete', 'visibility', 'visibility_off', 'lock', 'unlock',
      'download', 'upload', 'share', 'print', 'email', 'phone',
      'location_on', 'schedule', 'calendar_today', 'notifications',
      'dashboard', 'analytics', 'trending_up', 'trending_down',
      'attach_file', 'link', 'cloud', 'wifi', 'bluetooth', 'gps_fixed'
    ];

    // Funci√≥n para validar si un √≠cono existe en Material Icons
    function isValidMaterialIcon(iconName) {
      return validMaterialIcons.includes(iconName);
    }

    // Funci√≥n para obtener el √≠cono por defecto (del sistema o config)
    function getDefaultIcon() {
      return config.defaultIcon || 'person'; // Usar config o 'person' como fallback del sistema
    }
    
    // Configuraci√≥n b√°sica
    const config = {
      url: "../data/companies-board.csv",
      spacing: 140,
      nodeWidth: 100,
      nodeHeight: 125,
      treeSpacing: 100,
      clustersPerRow: "4 5 5 5", // Configuraci√≥n de clusters por fila (20 empresas: 5+5+5+5)
      clusterGapX: 80, // Gap horizontal entre clusters
      clusterGapY: 80, // Gap vertical entre filas de clusters
      defaultIcon: '' // √çcono por defecto cuando no es v√°lido
    };

    // Funci√≥n para construir la jerarqu√≠a
    function buildHierarchy(data) {
      const nodeMap = new Map();
      const trees = [];
      
      // Primera pasada: crear todos los nodos
      data.forEach(row => {
        if (row.Name && row.Name.trim()) {
          const node = {
            id: row.Node || row.Name,
            name: row.Name,
            parent: row.Parent || null,
            img: isValidMaterialIcon(row.Img) ? row.Img : getDefaultIcon(), // Validar √≠cono o usar √≠cono por defecto del sistema
            data: row,
            children: []
          };
          nodeMap.set(node.id, node);
        }
      });
      
      // Segunda pasada: establecer relaciones padre-hijo
      nodeMap.forEach(node => {
        if (node.parent && nodeMap.has(node.parent)) {
          const parent = nodeMap.get(node.parent);
          parent.children.push(node);
        } else {
          trees.push(node);
        }
      });
      
      console.log(`√Årboles encontrados: ${trees.length}`);
      trees.forEach((tree, i) => {
        console.log(`√Årbol ${i + 1}: ${tree.name} (${countNodes(tree)} nodos)`);
      });
      
      return trees;
    }
    
    // Funci√≥n para contar nodos en un √°rbol
    function countNodes(node) {
      let count = 1;
      node.children.forEach(child => {
        count += countNodes(child);
      });
      return count;
    }
    
    // Funci√≥n para calcular ancho de un √°rbol
    function calculateTreeWidth(node) {
      if (node.children.length === 0) {
        return config.nodeWidth;
      }
      
      let totalWidth = 0;
      node.children.forEach(child => {
        totalWidth += calculateTreeWidth(child);
      });
      
      return Math.max(totalWidth, config.nodeWidth);
    }
    
    // Funci√≥n para calcular altura de un √°rbol
    function calculateTreeHeight(node) {
      if (node.children.length === 0) {
        return config.nodeHeight;
      }
      
      let maxChildHeight = 0;
      node.children.forEach(child => {
        maxChildHeight = Math.max(maxChildHeight, calculateTreeHeight(child));
      });
      
      return config.nodeHeight + config.spacing + maxChildHeight;
    }
    
    // Funci√≥n para calcular l√≠mites de un cluster
    function calculateClusterBounds(tree) {
      const treeWidth = calculateTreeWidth(tree);
      const treeHeight = calculateTreeHeight(tree);
      
      return {
        width: treeWidth + 40,
        height: treeHeight + 60
      };
    }
    
    // Funci√≥n para obtener profundidad de un √°rbol
    function getTreeDepth(node, depth = 0) {
      if (node.children.length === 0) {
        return depth;
      }
      
      let maxDepth = depth;
      node.children.forEach(child => {
        maxDepth = Math.max(maxDepth, getTreeDepth(child, depth + 1));
      });
      
      return maxDepth;
    }
    
    // Funci√≥n principal de inicializaci√≥n
    async function initDiagram() {
      try {
        console.log('Iniciando diagrama...');
        
        // Crear contenedor SVG
        const svg = d3.select('#diagram');
        const container = svg.append('g');
        
        // Configurar zoom
        const zoom = d3.zoom()
          .scaleExtent([0.1, 5])
          .on('zoom', (event) => {
            container.attr('transform', event.transform);
            updateInfoPanel(event.transform);
          });
        
        // Aplicar zoom y desactivar doble clic
        svg.call(zoom);
        svg.on('dblclick.zoom', null);
        
        // Cargar datos
        const response = await fetch(config.url);
        const csvText = await response.text();
        
        Papa.parse(csvText, {
          header: true,
          complete: function(results) {
            console.log('Datos cargados:', results.data.length, 'filas');
            
            // Construir jerarqu√≠a
            const trees = buildHierarchy(results.data);
            
            // Guardar datos globales
            globalTrees = trees;
            globalContainer = container;
            
            // Medir tiempo de renderizado
            renderStartTime = performance.now();
            
            // Renderizar √°rboles
            renderTrees(trees, container);
          }
        });
        
      } catch (error) {
        console.error('Error cargando diagrama:', error);
      }
    }
    
    // Funci√≥n para renderizar √°rboles
    function renderTrees(trees, container) {
      console.log(`Renderizando ${trees.length} clusters con D3...`);
      
      // Calcular layout de clusters con configuraci√≥n flexible por fila
      const treeLayouts = [];
      const treeSpacing = config.treeSpacing;
      const clusterGapX = config.clusterGapX; // Gap horizontal entre clusters
      const clusterGapY = config.clusterGapY; // Gap vertical entre filas
      
      // Parsear configuraci√≥n de clusters por fila o calcular autom√°ticamente
      let clustersPerRowConfig;
      const defaultClustersPerRow = 7;
      
      if (config.clustersPerRow) {
        clustersPerRowConfig = config.clustersPerRow.split(' ').map(num => parseInt(num));
      } else {
        // Calcular distribuci√≥n autom√°tica basada en el n√∫mero de √°rboles
        const totalTrees = trees.length;
        const optimalClustersPerRow = Math.ceil(Math.sqrt(totalTrees)); // Distribuci√≥n cuadrada aproximada
        const rows = Math.ceil(totalTrees / optimalClustersPerRow);
        
        clustersPerRowConfig = [];
        for (let i = 0; i < rows; i++) {
          const clustersInThisRow = Math.min(optimalClustersPerRow, totalTrees - i * optimalClustersPerRow);
          clustersPerRowConfig.push(clustersInThisRow);
        }
        
        console.log(`Distribuci√≥n autom√°tica calculada: ${clustersPerRowConfig.join(' ')} para ${totalTrees} √°rboles`);
      }
      
      // Primera pasada: calcular dimensiones de todos los clusters
      const clusterDimensions = [];
      trees.forEach((tree, index) => {
        // Calcular layout temporal del √°rbol para obtener su ancho real
        renderTreeSimple(tree, d3.select('body').append('g').style('display', 'none'), 0, 0);
        
        // Calcular dimensiones del cluster de forma simple
        const treeBounds = calculateTreeBounds(tree);
        const realTreeWidth = treeBounds.maxX - treeBounds.minX;
        const realTreeHeight = treeBounds.maxY - treeBounds.minY;
        
        // Dimensiones del cluster con padding m√≠nimo
        const clusterWidth = realTreeWidth + 20; // Padding horizontal m√≠nimo
        const clusterHeight = Math.max(realTreeHeight, config.nodeHeight) + 140; // M√°s padding vertical (top y bottom)
        
        clusterDimensions.push({
          tree: tree,
          clusterWidth: clusterWidth,
          clusterHeight: clusterHeight,
          realTreeWidth: realTreeWidth,
          index: index
        });
      });
      
      // Calcular el ancho m√°ximo y altura m√°xima de cada fila usando configuraci√≥n flexible
      const rowMaxWidths = [];
      const rowMaxHeights = [];
      let currentIndex = 0;
      let row = 0;
      
      while (currentIndex < trees.length) {
        // Obtener n√∫mero de clusters para esta fila
        const clustersForThisRow = clustersPerRowConfig[row] || defaultClustersPerRow;
        const endIndex = Math.min(currentIndex + clustersForThisRow, trees.length);
        const rowClusters = clusterDimensions.slice(currentIndex, endIndex);
        
        // Calcular ancho total basado en el ancho del cluster (con padding)
        const rowTotalWidth = rowClusters.reduce((sum, cluster) => sum + cluster.clusterWidth, 0) + 
                             (rowClusters.length - 1) * clusterGapX;
        const rowMaxHeight = Math.max(...rowClusters.map(cluster => cluster.clusterHeight));
        
        rowMaxWidths.push(rowTotalWidth);
        rowMaxHeights.push(rowMaxHeight);
        console.log(`Fila ${row}: ${rowClusters.length} clusters, ancho real total: ${rowTotalWidth}, altura m√°xima: ${rowMaxHeight}`);
        
        currentIndex = endIndex;
        row++;
      }
      
      const totalRows = row;
      
      // Encontrar el ancho m√°ximo entre todas las filas - ESTA ES LA CLAVE
      const maxRowWidth = Math.max(...rowMaxWidths);
      console.log('Ancho m√°ximo de fila:', maxRowWidth, 'Anchos de filas:', rowMaxWidths);
      
      // Segunda pasada: calcular posiciones con ancho uniforme usando configuraci√≥n flexible
      let layoutIndex = 0;
      let layoutRow = 0;
      let accumulatedY = 30; // Posici√≥n Y acumulada desde el inicio
      
      while (layoutIndex < clusterDimensions.length) {
        // Obtener n√∫mero de clusters para esta fila
        const clustersForThisRow = clustersPerRowConfig[layoutRow] || defaultClustersPerRow;
        const endIndex = Math.min(layoutIndex + clustersForThisRow, clusterDimensions.length);
        const rowClusters = clusterDimensions.slice(layoutIndex, endIndex);
        
        // Obtener altura uniforme para esta fila
        const uniformClusterHeight = rowMaxHeights[layoutRow];
        
        // Calcular ancho m√≠nimo requerido para cada cluster en esta fila
        const minClusterWidths = rowClusters.map(cluster => cluster.clusterWidth); // Usar el ancho del cluster ya calculado
        const totalMinWidth = minClusterWidths.reduce((sum, width) => sum + width, 0);
        const totalGaps = rowClusters.length - 1;
        const totalGapWidth = totalGaps * clusterGapX;
        const totalRequiredWidth = totalMinWidth + totalGapWidth;
        
        // USAR EL ANCHO M√ÅXIMO DE TODAS LAS FILAS PARA MANTENER UNIFORMIDAD
        const effectiveRowWidth = maxRowWidth;
        const availableWidth = effectiveRowWidth - totalGapWidth;
        
        // Distribuir el espacio extra proporcionalmente si hay m√°s espacio disponible
        let extraSpace = 0;
        if (availableWidth > totalMinWidth) {
          extraSpace = availableWidth - totalMinWidth;
        }
        
        console.log(`Fila ${layoutRow}: ${clustersForThisRow} clusters, ancho requerido: ${totalRequiredWidth}px, ancho efectivo: ${effectiveRowWidth}px, espacio extra: ${extraSpace}px`);
        
        // Procesar cada cluster en esta fila
        rowClusters.forEach((cluster, col) => {
          // Calcular ancho del cluster: m√≠nimo requerido + espacio extra proporcional
          const minWidth = minClusterWidths[col];
          const extraSpaceForThisCluster = extraSpace > 0 ? Math.floor(extraSpace / rowClusters.length) : 0;
          const adjustedClusterWidth = minWidth + extraSpaceForThisCluster;
          
          // Calcular posici√≥n X centrada para toda la fila
          const startX = (window.innerWidth - effectiveRowWidth) / 2;
          let x = startX;
          
          // Acumular el ancho de los clusters anteriores
          for (let i = 0; i < col; i++) {
            const prevMinWidth = minClusterWidths[i];
            const prevExtraSpace = extraSpace > 0 ? Math.floor(extraSpace / rowClusters.length) : 0;
            const prevClusterWidth = prevMinWidth + prevExtraSpace;
            x += prevClusterWidth + clusterGapX;
          }
          
          // Usar posici√≥n Y acumulada para esta fila
          const y = accumulatedY;
          
          treeLayouts.push({
            tree: cluster.tree,
            clusterWidth: adjustedClusterWidth,
            clusterHeight: uniformClusterHeight, // Usar altura uniforme de la fila
            realTreeWidth: cluster.realTreeWidth,
            x: x,
            y: y,
            originalWidth: cluster.clusterWidth
          });
        });
        
        // Actualizar posici√≥n Y acumulada para la siguiente fila
        accumulatedY += uniformClusterHeight + clusterGapY;
        
        layoutIndex = endIndex;
        layoutRow++;
      }

      // Medir tiempo de renderizado si es la primera carga
      if (renderStartTime === 0) {
        renderStartTime = performance.now();
      }
      
      // Renderizar clusters
      const clusterGroups = [];
      treeLayouts.forEach((layout, index) => {
        const { tree, clusterWidth, clusterHeight, realTreeWidth, x, y } = layout;
        
        // Crear grupo del cluster
        const clusterGroup = container.append('g')
          .attr('class', 'cluster')
          .attr('transform', `translate(${x}, ${y})`);
        
        // Crear grupo para el √°rbol
        const treeGroup = clusterGroup.append('g')
          .attr('class', 'tree-group');
        
        // Fondo del cluster
        treeGroup.append('rect')
          .attr('class', 'cluster-bg')
          .attr('width', clusterWidth)
          .attr('height', clusterHeight)
          .attr('x', 0)
          .attr('y', 0);
        
        // T√≠tulo del cluster en esquina superior izquierda
        treeGroup.append('text')
          .attr('class', 'cluster-title')
          .attr('x', 15) // Margen izquierdo
          .attr('y', 28) // Margen superior aumentado
          .text(tree.name);
        
        // Crear grupo para el √°rbol
        const treeContentGroup = treeGroup.append('g')
          .attr('class', 'tree-content');
        
        // Calcular posici√≥n centrada del √°rbol dentro del cluster
        const treeX = (clusterWidth - config.nodeWidth) / 2;
        const treeY = 60; // M√°s espacio desde arriba para centrar mejor
        
        // Renderizar √°rbol
        renderTreeSimple(tree, treeContentGroup, treeX, treeY);
        
        // Agregar el cluster a la lista para eventos
        clusterGroups.push(clusterGroup);
      });
      
      // Agregar eventos de clic a los clusters
      addClusterClickEvents(clusterGroups, container);
      
      // Calcular tiempo de renderizado
      const renderTime = performance.now() - renderStartTime;
      
      // Actualizar contadores
      const totalNodes = countTotalNodes(trees);
      const totalClusters = trees.length;
      const nodeCountElement = document.getElementById('node-count');
      const clusterCountElement = document.getElementById('cluster-count');
      const renderTypeElement = document.getElementById('render-type');
      
      if (nodeCountElement) {
        nodeCountElement.textContent = totalNodes;
      }
      if (clusterCountElement) {
        clusterCountElement.textContent = totalClusters;
      }
      if (renderTypeElement) {
        renderTypeElement.textContent = 'SVG';
      }
      
      // Guardar datos globales para re-renderizado
      globalTrees = trees;
      globalContainer = container;
      
      // Calcular ancho total basado en el grid
      const maxWidth = window.innerWidth;
      const totalHeight = rowMaxHeights.reduce((sum, height, index) => {
        return sum + height + (index < rowMaxHeights.length - 1 ? clusterGapY : 0);
      }, 30); // 30px de margen superior
      
      console.log(`Layout completado. Grid: configuraci√≥n flexible, ${totalRows} filas`);
      console.log(`Dimensiones: ${maxWidth}px x ${totalHeight}px`);
      console.log(`Total de nodos: ${totalNodes}`);
      console.log(`Nodos renderizados con SVG: ${totalNodes}`);
      console.log(`Tiempo de renderizado: ${renderTime.toFixed(2)}ms`);
      console.log(`Ancho uniforme aplicado: ${maxRowWidth}px para todas las filas`);
      
      // Aplicar zoom inicial autom√°ticamente despu√©s del renderizado
      setTimeout(() => {
        applyInitialZoom(container, maxRowWidth, totalHeight);
      }, 100);

    }
    
    // Funci√≥n para renderizar √°rbol simple
    function renderTreeSimple(node, container, x = 0, y = 0, level = 0) {
      const nodeWidth = config.nodeWidth;
      const nodeHeight = config.nodeHeight;
      const spacing = config.spacing;
      
      // Crear grupo para el nodo
      const nodeGroup = container.append('g')
        .attr('class', 'node')
        .attr('transform', `translate(${x}, ${y})`);
      
      // Rect√°ngulo del nodo
      nodeGroup.append('rect')
        .attr('width', nodeWidth)
        .attr('height', nodeHeight);
      
      // √çcono de Material Icons (arriba del texto)
      const iconName = isValidMaterialIcon(node.img) ? node.img : getDefaultIcon(); // Validar √≠cono o usar √≠cono por defecto del sistema
      nodeGroup.append('text')
        .attr('class', 'material-icons')
        .attr('x', nodeWidth / 2)
        .attr('y', nodeHeight / 2 + 5)
        .text(iconName);
      
      // Texto principal (desplazado hacia abajo)
      nodeGroup.append('text')
        .attr('class', 'label-text')
        .attr('x', nodeWidth / 2)
        .attr('y', nodeHeight / 2 + 25)
        .text(node.name);
      
      // ID del nodo (desplazado hacia abajo)
      nodeGroup.append('text')
        .attr('class', 'label-id')
        .attr('x', nodeWidth / 2)
        .attr('y', nodeHeight / 2 + 40)
        .text(node.id);
      
      // Renderizar hijos
      if (node.children.length > 0) {
        const childY = y + nodeHeight + spacing;
        const totalChildWidth = node.children.length * (nodeWidth + spacing) - spacing;
        const startX = x - totalChildWidth / 2 + nodeWidth / 2;
        
        node.children.forEach((child, index) => {
          const childX = startX + index * (nodeWidth + spacing);
          
          // L√≠nea de conexi√≥n
          const parentCenterX = x + nodeWidth/2;
          const parentBottomY = y + nodeHeight;
          const childCenterX = childX + nodeWidth/2;
          const childTopY = childY;
          const midY = (parentBottomY + childTopY) / 2;
          
          container.append('path')
            .attr('class', 'link')
            .attr('d', `M ${parentCenterX} ${parentBottomY} 
                        L ${parentCenterX} ${midY} 
                        L ${childCenterX} ${midY} 
                        L ${childCenterX} ${childTopY}`);
          
          // Renderizar hijo recursivamente
          renderTreeSimple(child, container, childX, childY, level + 1);
        });
      }
    }
    
    // Funci√≥n para contar nodos totales
    function countTotalNodes(trees) {
      let total = 0;
      function countNodesRecursive(node) {
        total++;
        node.children.forEach(child => countNodesRecursive(child));
      }
      trees.forEach(tree => countNodesRecursive(tree));
      return total;
    }
    
    // Funci√≥n para calcular los l√≠mites de un √°rbol usando el mismo layout que renderTreeSimple
    function calculateTreeBounds(node) {
      let minX = 0, maxX = 0, minY = 0, maxY = 0;
      
      function traverseTree(n, x, y) {
        // Calcular l√≠mites del nodo actual
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x + config.nodeWidth);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y + config.nodeHeight);
        
        if (n.children.length > 0) {
          const childY = y + config.nodeHeight + config.spacing;
          const totalChildWidth = n.children.length * (config.nodeWidth + config.spacing) - config.spacing;
          const startX = x - totalChildWidth / 2 + config.nodeWidth / 2;
          
          n.children.forEach((child, index) => {
            const childX = startX + index * (config.nodeWidth + config.spacing);
            traverseTree(child, childX, childY);
          });
        }
      }
      
      traverseTree(node, 0, 0);
      
      // Asegurar que los l√≠mites sean al menos del tama√±o de un nodo
      if (maxX - minX < config.nodeWidth) {
        maxX = minX + config.nodeWidth;
      }
      if (maxY - minY < config.nodeHeight) {
        maxY = minY + config.nodeHeight;
      }
      
      return { minX, maxX, minY, maxY };
    }
    
    // Funci√≥n para calcular el ancho real de un √°rbol de forma m√°s simple y precisa
    function calculateTreeRealWidth(node) {
      // Si no tiene hijos, el ancho es el del nodo
      if (node.children.length === 0) {
        return config.nodeWidth;
      }
      
      // Calcular el ancho total de todos los hijos
      let totalChildrenWidth = 0;
      node.children.forEach(child => {
        totalChildrenWidth += calculateTreeRealWidth(child);
      });
      
      // Agregar espaciado entre hijos
      if (node.children.length > 1) {
        totalChildrenWidth += (node.children.length - 1) * config.spacing;
      }
      
      // El ancho del √°rbol es el m√°ximo entre el nodo actual y la suma de los hijos
      return Math.max(config.nodeWidth, totalChildrenWidth);
    }
    
    // Funci√≥n para actualizar el panel de informaci√≥n
    function updateInfoPanel(transform) {
      const zoomElement = document.getElementById('zoom-level');
      const translateXElement = document.getElementById('translate-x');
      const translateYElement = document.getElementById('translate-y');
      
      if (zoomElement) {
        zoomElement.textContent = transform.k.toFixed(2) + 'x';
      }
      if (translateXElement) {
        translateXElement.textContent = Math.round(transform.x);
      }
      if (translateYElement) {
        translateYElement.textContent = Math.round(transform.y);
      }
    }
    
    // Funci√≥n para hacer zoom a un cluster espec√≠fico
    function zoomToCluster(clusterGroup, container) {
      console.log('=== INICIO ZOOM TO CLUSTER ===');
      console.log('Cluster title:', clusterGroup.select('.cluster-title').text());
      
      // Obtener las dimensiones del SVG
      const svg = d3.select('#diagram');
      const svgWidth = 1910; // Ancho fijo del SVG
      const svgHeight = 967;  // Alto fijo del SVG
      
      console.log('SVG dimensions:', svgWidth, 'x', svgHeight);
      
      // Obtener las dimensiones del cluster
      const clusterWidth = parseFloat(clusterGroup.select('.cluster-bg').attr('width'));
      const clusterHeight = parseFloat(clusterGroup.select('.cluster-bg').attr('height'));
      
      console.log('Cluster dimensions:', clusterWidth, 'x', clusterHeight);
      
      // Obtener la posici√≥n actual del cluster en el SVG
      const clusterTransform = clusterGroup.attr('transform');
      console.log('Cluster transform:', clusterTransform);
      
      // Extraer las coordenadas del cluster desde su transform
      let clusterX = 0, clusterY = 0;
      if (clusterTransform) {
        const match = clusterTransform.match(/translate\(([^,]+),\s*([^)]+)\)/);
        if (match) {
          clusterX = parseFloat(match[1]);
          clusterY = parseFloat(match[2]);
        }
      }
      
      console.log('Cluster position in SVG:', clusterX, clusterY);
      
      // Calcular el centro del cluster
      const clusterCenterX = clusterX + clusterWidth / 2;
      const clusterCenterY = clusterY + clusterHeight / 2;
      
      console.log('Cluster center:', clusterCenterX, clusterY);
      
      // Calcular el zoom necesario para que el cluster ocupe el 70% del viewport
      const scaleX = svgWidth * 0.7 / clusterWidth;
      const scaleY = svgHeight * 0.7 / clusterHeight;
      const scale = Math.min(scaleX, scaleY, 4); // Limitar el zoom m√°ximo a 4x
      
      console.log('Scale calculations:');
      console.log('  scaleX:', scaleX, 'scaleY:', scaleY, 'final scale:', scale);
      
      // Calcular la nueva posici√≥n para centrar el cluster en el SVG
      const newX = svgWidth / 2 - clusterCenterX * scale;
      const newY = svgHeight / 2 - clusterCenterY * scale;
      
      console.log('New position to center cluster:', newX, newY);
      
      // Aplicar la transformaci√≥n con animaci√≥n
      const finalTransform = `translate(${newX}, ${newY}) scale(${scale})`;
      console.log('Applying transform:', finalTransform);
      
      container.transition()
        .duration(1200)
        .ease(d3.easeCubicOut)
        .attr('transform', finalTransform)
        .on('end', function() {
          // Actualizar el estado del zoom de D3 despu√©s de la animaci√≥n
          const svg = d3.select('#diagram');
          const zoom = d3.zoomTransform(svg.node());
          
          // Crear la nueva transformaci√≥n
          const newTransform = d3.zoomIdentity
            .translate(newX, newY)
            .scale(scale);
          
          // Aplicar la transformaci√≥n al estado del zoom de D3
          svg.call(d3.zoom().transform, newTransform);
          
          console.log('Estado del zoom de D3 actualizado:', {
            x: newX.toFixed(0),
            y: newY.toFixed(0),
            k: scale.toFixed(3)
          });
        });
      
      // Actualizar el panel de informaci√≥n
      updateInfoPanel({ k: scale, x: newX, y: newY });
      
      // Mostrar indicador de zoom
      const zoomStatus = document.getElementById('zoom-status');
      if (zoomStatus) {
        zoomStatus.style.display = 'block';
        setTimeout(() => {
          zoomStatus.style.display = 'none';
        }, 2000);
      }
      
      // Agregar efecto visual al cluster seleccionado
      clusterGroup.select('.cluster-bg')
        .transition()
        .duration(300)
        .style('stroke', '#007bff')
        .style('stroke-width', '5px');
      
      // Remover el efecto despu√©s de un tiempo
      setTimeout(() => {
        clusterGroup.select('.cluster-bg')
          .transition()
          .duration(300)
          .style('stroke', '#dee2e6')
          .style('stroke-width', '3px');
      }, 1500);
      
      console.log(`=== DEBUG ZOOM CLUSTER ===`);
      console.log(`Cluster seleccionado: ${clusterGroup.select('.cluster-title').text()}`);
      console.log(`Posici√≥n del cluster: (${clusterX}, ${clusterY})`);
      console.log(`Centro del cluster: (${clusterCenterX}, ${clusterCenterY})`);
      console.log(`Dimensiones del cluster: ${clusterWidth}x${clusterHeight}`);
      console.log(`Dimensiones del SVG: ${svgWidth}x${svgHeight}`);
      console.log(`Escala calculada: ${scale.toFixed(2)}x`);
      console.log(`Nueva posici√≥n: (${newX.toFixed(0)}, ${newY.toFixed(0)})`);
      console.log(`=== FIN ZOOM TO CLUSTER ===`);
      console.log(`========================`);
    }
    
    // Funci√≥n para aplicar zoom inicial autom√°tico
    function applyInitialZoom(container, diagramWidth, diagramHeight) {
      // Obtener las dimensiones reales del viewport
      const svg = d3.select('#diagram');
      const svgNode = svg.node();
      const svgRect = svgNode.getBoundingClientRect();
      const svgWidth = svgRect.width;
      const svgHeight = svgRect.height;
      
      console.log('Dimensiones reales del SVG:', svgWidth, 'x', svgHeight);
      
      // Calcular escala para que el ancho del diagrama quepa en el viewport
      const scaleX = svgWidth / diagramWidth;
      const scaleY = svgHeight / diagramHeight;
      const scale = Math.min(scaleX, scaleY) * 0.9; // 90% para dejar un poco de margen
      
      // Calcular el ancho del diagrama escalado
      const scaledDiagramWidth = diagramWidth * scale;
      
      // Centrar horizontalmente en el viewport disponible
      const translateX = (svgWidth - scaledDiagramWidth) / 2;
      const translateY = 30; // Margen superior fijo
      
      console.log('C√°lculos de centrado:', {
        diagramWidth: diagramWidth,
        scaledDiagramWidth: scaledDiagramWidth.toFixed(0),
        svgWidth: svgWidth,
        translateX: translateX.toFixed(0)
      });
      
      // Aplicar transformaci√≥n inicial sin animaci√≥n
      container.attr('transform', `translate(${translateX}, ${translateY}) scale(${scale})`);
      
      // Actualizar el panel de informaci√≥n
      updateInfoPanel({ k: scale, x: translateX, y: translateY });
      
      console.log('Zoom inicial aplicado:', {
        scale: scale.toFixed(3),
        translateX: translateX.toFixed(0),
        translateY: translateY.toFixed(0),
        diagramWidth: diagramWidth,
        diagramHeight: diagramHeight,
        svgWidth: svgWidth,
        svgHeight: svgHeight
      });
    }
    
    // Funci√≥n para aplicar zoom inicial con animaci√≥n
    function applyInitialZoomWithAnimation(container, diagramWidth, diagramHeight) {
      // Obtener las dimensiones reales del viewport
      const svg = d3.select('#diagram');
      const svgNode = svg.node();
      const svgRect = svgNode.getBoundingClientRect();
      const svgWidth = svgRect.width;
      const svgHeight = svgRect.height;
      
      // Calcular escala para que el ancho del diagrama quepa en el viewport
      const scaleX = svgWidth / diagramWidth;
      const scaleY = svgHeight / diagramHeight;
      const scale = Math.min(scaleX, scaleY) * 0.9; // 90% para dejar un poco de margen
      
      // Calcular el ancho del diagrama escalado
      const scaledDiagramWidth = diagramWidth * scale;
      
      // Centrar horizontalmente en el viewport disponible
      const translateX = (svgWidth - scaledDiagramWidth) / 2;
      const translateY = 30; // Margen superior fijo
      
      // Aplicar transformaci√≥n con animaci√≥n
      container.transition()
        .duration(1000)
        .ease(d3.easeCubicOut)
        .attr('transform', `translate(${translateX}, ${translateY}) scale(${scale})`);
      
      // Actualizar el panel de informaci√≥n
      updateInfoPanel({ k: scale, x: translateX, y: translateY });
      
      console.log('Zoom inicial con animaci√≥n aplicado:', {
        scale: scale.toFixed(3),
        translateX: translateX.toFixed(0),
        translateY: translateY.toFixed(0),
        svgWidth: svgWidth,
        svgHeight: svgHeight,
        scaledDiagramWidth: scaledDiagramWidth.toFixed(0)
      });
    }
    
    // Funci√≥n para resetear el zoom
    function resetZoom(container) {
      // Usar las dimensiones reales del diagrama (aproximadamente 8360x8565 seg√∫n los logs)
      const diagramWidth = 8360;
      const diagramHeight = 8565;
      
      // Aplicar zoom inicial con animaci√≥n
      applyInitialZoomWithAnimation(container, diagramWidth, diagramHeight);
      
      // Ocultar indicador de zoom
      const zoomStatus = document.getElementById('zoom-status');
      if (zoomStatus) {
        zoomStatus.style.display = 'none';
      }
      
      console.log('Zoom reseteado a vista completa');
    }
    
    // Funci√≥n para agregar eventos de clic a los clusters
    function addClusterClickEvents(clusterGroups, container) {
      clusterGroups.forEach(clusterGroup => {
        // Agregar evento de clic al fondo del cluster
        clusterGroup.select('.cluster-bg')
          .style('cursor', 'pointer')
          .on('click', function(event) {
            event.stopPropagation();
            console.log('CLICK en cluster-bg:', clusterGroup.select('.cluster-title').text());
            zoomToCluster(clusterGroup, container);
          });
        
        // Agregar evento de clic al t√≠tulo del cluster
        clusterGroup.select('.cluster-title')
          .style('cursor', 'pointer')
          .on('click', function(event) {
            event.stopPropagation();
            console.log('CLICK en cluster-title:', clusterGroup.select('.cluster-title').text());
            zoomToCluster(clusterGroup, container);
          });
      });
      
      // Agregar evento de doble clic al SVG para resetear zoom
      d3.select('#diagram').on('dblclick', function(event) {
        // Hacer reset desde cualquier parte del diagrama
        console.log('Doble clic - reseteando zoom');
        resetZoom(container);
      });
      
      // El bot√≥n de reset se elimin√≥, ahora se usa doble clic
      
      console.log('Eventos de clic agregados a los clusters');
    }
    

    
    // Inicializar cuando la p√°gina est√© lista
    document.addEventListener('DOMContentLoaded', initDiagram);
  </script>
</body>
</html>
