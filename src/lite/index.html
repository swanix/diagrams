<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Swanix Diagrams Lite</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #2c3e50;
      color: #333;
    }
    
    .xcanvas {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    
    svg {
      width: 100%;
      height: 100%;
    }
    
    .node rect {
      fill: #fff;
      stroke: #ccc;
      stroke-width: 1px;
      rx: 4px;
    }
    
    .node:hover rect {
      stroke: #999;
    }
    
    .label-text {
      font-size: 12px;
      fill: #333;
      text-anchor: middle;
    }
    
    .label-id {
      font-size: 10px;
      fill: #666;
      text-anchor: middle;
    }
    
    .cluster-title {
      font-size: 20px;
      font-weight: bold;
      fill: #333;
      text-anchor: start;
    }
    
    .cluster-bg {
      fill: #f8f9fa;
      stroke: #dee2e6;
      stroke-width: 3px;
      rx: 12px;
      opacity: 0.95;
    }
    
    .cluster-container {
      overflow: hidden;
    }
    
    .info-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(33, 33, 33, 0.95);
      border: 1px solid #555;
      border-radius: 8px;
      padding: 15px;
      font-family: monospace;
      font-size: 12px;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      min-width: 200px;
    }
    
    .info-panel h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #fff;
    }
    
    .info-item {
      margin: 5px 0;
      color: #ccc;
    }
    
    .link {
      fill: none;
      stroke: #999;
      stroke-width: 1px;
    }
    
    .material-icons {
      font-family: 'Material Icons';
      font-weight: normal;
      font-style: normal;
      font-size: 48px;
      line-height: 1;
      letter-spacing: normal;
      text-transform: none;
      display: inline-block;
      white-space: nowrap;
      word-wrap: normal;
      direction: ltr;
      -webkit-font-feature-settings: 'liga';
      -webkit-font-smoothing: antialiased;
      fill: #666;
      text-anchor: middle;
    }
    

  </style>
</head>
<body>

  
      <div class="info-panel">
      <h3>Información del Diagrama</h3>
      <div class="info-item"><strong>Nodos: <span id="node-count">0</span></strong></div>
      <div class="info-item">Clusters: <span id="cluster-count">0</span></div>
      <div class="info-item">Zoom: <span id="zoom-level">1.00x</span></div>
      <div class="info-item">Posición X: <span id="translate-x">0</span></div>
      <div class="info-item">Posición Y: <span id="translate-y">0</span></div>
      <div class="info-item">Tipo: <span id="render-type">SVG</span></div>
    </div>

  <div class="xcanvas">
    <svg id="diagram"></svg>
  </div>

  <script src="https://unpkg.com/d3@7.9.0/dist/d3.min.js"></script>
  <script src="https://unpkg.com/papaparse@5.3.0/papaparse.min.js"></script>

  <script>
    // Variables globales
    let globalTrees = [];
    let globalContainer = null;
    let renderStartTime = 0;
    
    // Lista de íconos válidos de Material Icons
    const validMaterialIcons = [
      'person', 'business', 'computer', 'supervisor_account', 'manage_accounts', 
      'code', 'star', 'school', 'settings', 'campaign', 'point_of_sale',
      'account_balance', 'work', 'home', 'search', 'favorite', 'info',
      'warning', 'error', 'check_circle', 'cancel', 'add', 'remove',
      'edit', 'delete', 'visibility', 'visibility_off', 'lock', 'unlock',
      'download', 'upload', 'share', 'print', 'email', 'phone',
      'location_on', 'schedule', 'calendar_today', 'notifications',
      'dashboard', 'analytics', 'trending_up', 'trending_down',
      'attach_file', 'link', 'cloud', 'wifi', 'bluetooth', 'gps_fixed'
    ];

    // Función para validar si un ícono existe en Material Icons
    function isValidMaterialIcon(iconName) {
      return validMaterialIcons.includes(iconName);
    }

    // Función para obtener el ícono por defecto (del sistema o config)
    function getDefaultIcon() {
      return config.defaultIcon || 'person'; // Usar config o 'person' como fallback del sistema
    }
    
    // Configuración básica
    const config = {
      url: "../data/companies-board.csv",
      spacing: 140,
      nodeWidth: 100,
      nodeHeight: 125,
      treeSpacing: 100,
      clustersPerRow: "4 5 5 5", // Configuración de clusters por fila (20 empresas: 5+5+5+5)
      clusterGapX: 80, // Gap horizontal entre clusters
      clusterGapY: 80, // Gap vertical entre filas de clusters
      defaultIcon: '' // Ícono por defecto cuando no es válido
    };

    // Función para construir la jerarquía
    function buildHierarchy(data) {
      const nodeMap = new Map();
      const trees = [];
      
      // Primera pasada: crear todos los nodos
      data.forEach(row => {
        if (row.Name && row.Name.trim()) {
          const node = {
            id: row.Node || row.Name,
            name: row.Name,
            parent: row.Parent || null,
            img: isValidMaterialIcon(row.Img) ? row.Img : getDefaultIcon(), // Validar ícono o usar ícono por defecto del sistema
            data: row,
            children: []
          };
          nodeMap.set(node.id, node);
        }
      });
      
      // Segunda pasada: establecer relaciones padre-hijo
      nodeMap.forEach(node => {
        if (node.parent && nodeMap.has(node.parent)) {
          const parent = nodeMap.get(node.parent);
          parent.children.push(node);
        } else {
          trees.push(node);
        }
      });
      
      console.log(`Árboles encontrados: ${trees.length}`);
      trees.forEach((tree, i) => {
        console.log(`Árbol ${i + 1}: ${tree.name} (${countNodes(tree)} nodos)`);
      });
      
      return trees;
    }
    
    // Función para contar nodos en un árbol
    function countNodes(node) {
      let count = 1;
      node.children.forEach(child => {
        count += countNodes(child);
      });
      return count;
    }
    
    // Función para calcular ancho de un árbol
    function calculateTreeWidth(node) {
      if (node.children.length === 0) {
        return config.nodeWidth;
      }
      
      let totalWidth = 0;
      node.children.forEach(child => {
        totalWidth += calculateTreeWidth(child);
      });
      
      return Math.max(totalWidth, config.nodeWidth);
    }
    
    // Función para calcular altura de un árbol
    function calculateTreeHeight(node) {
      if (node.children.length === 0) {
        return config.nodeHeight;
      }
      
      let maxChildHeight = 0;
      node.children.forEach(child => {
        maxChildHeight = Math.max(maxChildHeight, calculateTreeHeight(child));
      });
      
      return config.nodeHeight + config.spacing + maxChildHeight;
    }
    
    // Función para calcular límites de un cluster
    function calculateClusterBounds(tree) {
      const treeWidth = calculateTreeWidth(tree);
      const treeHeight = calculateTreeHeight(tree);
      
      return {
        width: treeWidth + 40,
        height: treeHeight + 60
      };
    }
    
    // Función para obtener profundidad de un árbol
    function getTreeDepth(node, depth = 0) {
      if (node.children.length === 0) {
        return depth;
      }
      
      let maxDepth = depth;
      node.children.forEach(child => {
        maxDepth = Math.max(maxDepth, getTreeDepth(child, depth + 1));
      });
      
      return maxDepth;
    }
    
    // Función principal de inicialización
    async function initDiagram() {
      try {
        console.log('Iniciando diagrama...');
        
        // Crear contenedor SVG
        const svg = d3.select('#diagram');
        const container = svg.append('g');
        
        // Configurar zoom
        const zoom = d3.zoom()
          .scaleExtent([0.1, 5])
          .on('zoom', (event) => {
            container.attr('transform', event.transform);
            updateInfoPanel(event.transform);
          });
        
        svg.call(zoom);
        
        // Cargar datos
        const response = await fetch(config.url);
        const csvText = await response.text();
        
        Papa.parse(csvText, {
          header: true,
          complete: function(results) {
            console.log('Datos cargados:', results.data.length, 'filas');
            
            // Construir jerarquía
            const trees = buildHierarchy(results.data);
            
            // Guardar datos globales
            globalTrees = trees;
            globalContainer = container;
            
            // Medir tiempo de renderizado
            renderStartTime = performance.now();
            
            // Renderizar árboles
            renderTrees(trees, container);
          }
        });
        
      } catch (error) {
        console.error('Error cargando diagrama:', error);
      }
    }
    
    // Función para renderizar árboles
    function renderTrees(trees, container) {
      console.log(`Renderizando ${trees.length} clusters con D3...`);
      
      // Calcular layout de clusters con configuración flexible por fila
      const treeLayouts = [];
      const treeSpacing = config.treeSpacing;
      const clusterGapX = config.clusterGapX; // Gap horizontal entre clusters
      const clusterGapY = config.clusterGapY; // Gap vertical entre filas
      
      // Parsear configuración de clusters por fila o calcular automáticamente
      let clustersPerRowConfig;
      const defaultClustersPerRow = 7;
      
      if (config.clustersPerRow) {
        clustersPerRowConfig = config.clustersPerRow.split(' ').map(num => parseInt(num));
      } else {
        // Calcular distribución automática basada en el número de árboles
        const totalTrees = trees.length;
        const optimalClustersPerRow = Math.ceil(Math.sqrt(totalTrees)); // Distribución cuadrada aproximada
        const rows = Math.ceil(totalTrees / optimalClustersPerRow);
        
        clustersPerRowConfig = [];
        for (let i = 0; i < rows; i++) {
          const clustersInThisRow = Math.min(optimalClustersPerRow, totalTrees - i * optimalClustersPerRow);
          clustersPerRowConfig.push(clustersInThisRow);
        }
        
        console.log(`Distribución automática calculada: ${clustersPerRowConfig.join(' ')} para ${totalTrees} árboles`);
      }
      
      // Primera pasada: calcular dimensiones de todos los clusters
      const clusterDimensions = [];
      trees.forEach((tree, index) => {
        // Calcular layout temporal del árbol para obtener su ancho real
        renderTreeSimple(tree, d3.select('body').append('g').style('display', 'none'), 0, 0);
        
        // Calcular dimensiones del cluster de forma simple
        const treeBounds = calculateTreeBounds(tree);
        const realTreeWidth = treeBounds.maxX - treeBounds.minX;
        const realTreeHeight = treeBounds.maxY - treeBounds.minY;
        
        // Dimensiones del cluster con padding mínimo
        const clusterWidth = realTreeWidth + 20; // Padding horizontal mínimo
        const clusterHeight = Math.max(realTreeHeight, config.nodeHeight) + 140; // Más padding vertical (top y bottom)
        
        clusterDimensions.push({
          tree: tree,
          clusterWidth: clusterWidth,
          clusterHeight: clusterHeight,
          realTreeWidth: realTreeWidth,
          index: index
        });
      });
      
      // Calcular el ancho máximo y altura máxima de cada fila usando configuración flexible
      const rowMaxWidths = [];
      const rowMaxHeights = [];
      let currentIndex = 0;
      let row = 0;
      
      while (currentIndex < trees.length) {
        // Obtener número de clusters para esta fila
        const clustersForThisRow = clustersPerRowConfig[row] || defaultClustersPerRow;
        const endIndex = Math.min(currentIndex + clustersForThisRow, trees.length);
        const rowClusters = clusterDimensions.slice(currentIndex, endIndex);
        
        // Calcular ancho total basado en el ancho del cluster (con padding)
        const rowTotalWidth = rowClusters.reduce((sum, cluster) => sum + cluster.clusterWidth, 0) + 
                             (rowClusters.length - 1) * clusterGapX;
        const rowMaxHeight = Math.max(...rowClusters.map(cluster => cluster.clusterHeight));
        
        rowMaxWidths.push(rowTotalWidth);
        rowMaxHeights.push(rowMaxHeight);
        console.log(`Fila ${row}: ${rowClusters.length} clusters, ancho real total: ${rowTotalWidth}, altura máxima: ${rowMaxHeight}`);
        
        currentIndex = endIndex;
        row++;
      }
      
      const totalRows = row;
      
      // Encontrar el ancho máximo entre todas las filas - ESTA ES LA CLAVE
      const maxRowWidth = Math.max(...rowMaxWidths);
      console.log('Ancho máximo de fila:', maxRowWidth, 'Anchos de filas:', rowMaxWidths);
      
      // Segunda pasada: calcular posiciones con ancho uniforme usando configuración flexible
      let layoutIndex = 0;
      let layoutRow = 0;
      let accumulatedY = 30; // Posición Y acumulada desde el inicio
      
      while (layoutIndex < clusterDimensions.length) {
        // Obtener número de clusters para esta fila
        const clustersForThisRow = clustersPerRowConfig[layoutRow] || defaultClustersPerRow;
        const endIndex = Math.min(layoutIndex + clustersForThisRow, clusterDimensions.length);
        const rowClusters = clusterDimensions.slice(layoutIndex, endIndex);
        
        // Obtener altura uniforme para esta fila
        const uniformClusterHeight = rowMaxHeights[layoutRow];
        
        // Calcular ancho mínimo requerido para cada cluster en esta fila
        const minClusterWidths = rowClusters.map(cluster => cluster.clusterWidth); // Usar el ancho del cluster ya calculado
        const totalMinWidth = minClusterWidths.reduce((sum, width) => sum + width, 0);
        const totalGaps = rowClusters.length - 1;
        const totalGapWidth = totalGaps * clusterGapX;
        const totalRequiredWidth = totalMinWidth + totalGapWidth;
        
        // USAR EL ANCHO MÁXIMO DE TODAS LAS FILAS PARA MANTENER UNIFORMIDAD
        const effectiveRowWidth = maxRowWidth;
        const availableWidth = effectiveRowWidth - totalGapWidth;
        
        // Distribuir el espacio extra proporcionalmente si hay más espacio disponible
        let extraSpace = 0;
        if (availableWidth > totalMinWidth) {
          extraSpace = availableWidth - totalMinWidth;
        }
        
        console.log(`Fila ${layoutRow}: ${clustersForThisRow} clusters, ancho requerido: ${totalRequiredWidth}px, ancho efectivo: ${effectiveRowWidth}px, espacio extra: ${extraSpace}px`);
        
        // Procesar cada cluster en esta fila
        rowClusters.forEach((cluster, col) => {
          // Calcular ancho del cluster: mínimo requerido + espacio extra proporcional
          const minWidth = minClusterWidths[col];
          const extraSpaceForThisCluster = extraSpace > 0 ? Math.floor(extraSpace / rowClusters.length) : 0;
          const adjustedClusterWidth = minWidth + extraSpaceForThisCluster;
          
          // Calcular posición X centrada para toda la fila
          const startX = (window.innerWidth - effectiveRowWidth) / 2;
          let x = startX;
          
          // Acumular el ancho de los clusters anteriores
          for (let i = 0; i < col; i++) {
            const prevMinWidth = minClusterWidths[i];
            const prevExtraSpace = extraSpace > 0 ? Math.floor(extraSpace / rowClusters.length) : 0;
            const prevClusterWidth = prevMinWidth + prevExtraSpace;
            x += prevClusterWidth + clusterGapX;
          }
          
          // Usar posición Y acumulada para esta fila
          const y = accumulatedY;
          
          treeLayouts.push({
            tree: cluster.tree,
            clusterWidth: adjustedClusterWidth,
            clusterHeight: uniformClusterHeight, // Usar altura uniforme de la fila
            realTreeWidth: cluster.realTreeWidth,
            x: x,
            y: y,
            originalWidth: cluster.clusterWidth
          });
        });
        
        // Actualizar posición Y acumulada para la siguiente fila
        accumulatedY += uniformClusterHeight + clusterGapY;
        
        layoutIndex = endIndex;
        layoutRow++;
      }

      // Medir tiempo de renderizado si es la primera carga
      if (renderStartTime === 0) {
        renderStartTime = performance.now();
      }
      
      // Renderizar clusters
      treeLayouts.forEach((layout, index) => {
        const { tree, clusterWidth, clusterHeight, realTreeWidth, x, y } = layout;
        
        // Crear grupo del cluster
        const clusterGroup = container.append('g')
          .attr('class', 'cluster')
          .attr('transform', `translate(${x}, ${y})`);
        
        // Crear grupo para el árbol
        const treeGroup = clusterGroup.append('g')
          .attr('class', 'tree-group');
        
        // Fondo del cluster
        treeGroup.append('rect')
          .attr('class', 'cluster-bg')
          .attr('width', clusterWidth)
          .attr('height', clusterHeight)
          .attr('x', 0)
          .attr('y', 0);
        
        // Título del cluster en esquina superior izquierda
        treeGroup.append('text')
          .attr('class', 'cluster-title')
          .attr('x', 15) // Margen izquierdo
          .attr('y', 28) // Margen superior aumentado
          .text(tree.name);
        
        // Crear grupo para el árbol
        const treeContentGroup = treeGroup.append('g')
          .attr('class', 'tree-content');
        
        // Calcular posición centrada del árbol dentro del cluster
        const treeX = (clusterWidth - config.nodeWidth) / 2;
        const treeY = 60; // Más espacio desde arriba para centrar mejor
        
        // Renderizar árbol
        renderTreeSimple(tree, treeContentGroup, treeX, treeY);
      });
      
      // Calcular tiempo de renderizado
      const renderTime = performance.now() - renderStartTime;
      
      // Actualizar contadores
      const totalNodes = countTotalNodes(trees);
      const totalClusters = trees.length;
      const nodeCountElement = document.getElementById('node-count');
      const clusterCountElement = document.getElementById('cluster-count');
      const renderTypeElement = document.getElementById('render-type');
      
      if (nodeCountElement) {
        nodeCountElement.textContent = totalNodes;
      }
      if (clusterCountElement) {
        clusterCountElement.textContent = totalClusters;
      }
      if (renderTypeElement) {
        renderTypeElement.textContent = 'SVG';
      }
      
      // Guardar datos globales para re-renderizado
      globalTrees = trees;
      globalContainer = container;
      
      // Calcular ancho total basado en el grid
      const maxWidth = window.innerWidth;
      const totalHeight = rowMaxHeights.reduce((sum, height, index) => {
        return sum + height + (index < rowMaxHeights.length - 1 ? clusterGapY : 0);
      }, 30); // 30px de margen superior
      
      console.log(`Layout completado. Grid: configuración flexible, ${totalRows} filas`);
      console.log(`Dimensiones: ${maxWidth}px x ${totalHeight}px`);
      console.log(`Total de nodos: ${totalNodes}`);
      console.log(`Nodos renderizados con SVG: ${totalNodes}`);
      console.log(`Tiempo de renderizado: ${renderTime.toFixed(2)}ms`);
      console.log(`Ancho uniforme aplicado: ${maxRowWidth}px para todas las filas`);

    }
    
    // Función para renderizar árbol simple
    function renderTreeSimple(node, container, x = 0, y = 0, level = 0) {
      const nodeWidth = config.nodeWidth;
      const nodeHeight = config.nodeHeight;
      const spacing = config.spacing;
      
      // Crear grupo para el nodo
      const nodeGroup = container.append('g')
        .attr('class', 'node')
        .attr('transform', `translate(${x}, ${y})`);
      
      // Rectángulo del nodo
      nodeGroup.append('rect')
        .attr('width', nodeWidth)
        .attr('height', nodeHeight);
      
      // Ícono de Material Icons (arriba del texto)
      const iconName = isValidMaterialIcon(node.img) ? node.img : getDefaultIcon(); // Validar ícono o usar ícono por defecto del sistema
      nodeGroup.append('text')
        .attr('class', 'material-icons')
        .attr('x', nodeWidth / 2)
        .attr('y', nodeHeight / 2 + 5)
        .text(iconName);
      
      // Texto principal (desplazado hacia abajo)
      nodeGroup.append('text')
        .attr('class', 'label-text')
        .attr('x', nodeWidth / 2)
        .attr('y', nodeHeight / 2 + 25)
        .text(node.name);
      
      // ID del nodo (desplazado hacia abajo)
      nodeGroup.append('text')
        .attr('class', 'label-id')
        .attr('x', nodeWidth / 2)
        .attr('y', nodeHeight / 2 + 40)
        .text(node.id);
      
      // Renderizar hijos
      if (node.children.length > 0) {
        const childY = y + nodeHeight + spacing;
        const totalChildWidth = node.children.length * (nodeWidth + spacing) - spacing;
        const startX = x - totalChildWidth / 2 + nodeWidth / 2;
        
        node.children.forEach((child, index) => {
          const childX = startX + index * (nodeWidth + spacing);
          
          // Línea de conexión
          const parentCenterX = x + nodeWidth/2;
          const parentBottomY = y + nodeHeight;
          const childCenterX = childX + nodeWidth/2;
          const childTopY = childY;
          const midY = (parentBottomY + childTopY) / 2;
          
          container.append('path')
            .attr('class', 'link')
            .attr('d', `M ${parentCenterX} ${parentBottomY} 
                        L ${parentCenterX} ${midY} 
                        L ${childCenterX} ${midY} 
                        L ${childCenterX} ${childTopY}`);
          
          // Renderizar hijo recursivamente
          renderTreeSimple(child, container, childX, childY, level + 1);
        });
      }
    }
    
    // Función para contar nodos totales
    function countTotalNodes(trees) {
      let total = 0;
      function countNodesRecursive(node) {
        total++;
        node.children.forEach(child => countNodesRecursive(child));
      }
      trees.forEach(tree => countNodesRecursive(tree));
      return total;
    }
    
    // Función para calcular los límites de un árbol usando el mismo layout que renderTreeSimple
    function calculateTreeBounds(node) {
      let minX = 0, maxX = 0, minY = 0, maxY = 0;
      
      function traverseTree(n, x, y) {
        // Calcular límites del nodo actual
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x + config.nodeWidth);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y + config.nodeHeight);
        
        if (n.children.length > 0) {
          const childY = y + config.nodeHeight + config.spacing;
          const totalChildWidth = n.children.length * (config.nodeWidth + config.spacing) - config.spacing;
          const startX = x - totalChildWidth / 2 + config.nodeWidth / 2;
          
          n.children.forEach((child, index) => {
            const childX = startX + index * (config.nodeWidth + config.spacing);
            traverseTree(child, childX, childY);
          });
        }
      }
      
      traverseTree(node, 0, 0);
      
      // Asegurar que los límites sean al menos del tamaño de un nodo
      if (maxX - minX < config.nodeWidth) {
        maxX = minX + config.nodeWidth;
      }
      if (maxY - minY < config.nodeHeight) {
        maxY = minY + config.nodeHeight;
      }
      
      return { minX, maxX, minY, maxY };
    }
    
    // Función para calcular el ancho real de un árbol de forma más simple y precisa
    function calculateTreeRealWidth(node) {
      // Si no tiene hijos, el ancho es el del nodo
      if (node.children.length === 0) {
        return config.nodeWidth;
      }
      
      // Calcular el ancho total de todos los hijos
      let totalChildrenWidth = 0;
      node.children.forEach(child => {
        totalChildrenWidth += calculateTreeRealWidth(child);
      });
      
      // Agregar espaciado entre hijos
      if (node.children.length > 1) {
        totalChildrenWidth += (node.children.length - 1) * config.spacing;
      }
      
      // El ancho del árbol es el máximo entre el nodo actual y la suma de los hijos
      return Math.max(config.nodeWidth, totalChildrenWidth);
    }
    
    // Función para actualizar el panel de información
    function updateInfoPanel(transform) {
      const zoomElement = document.getElementById('zoom-level');
      const translateXElement = document.getElementById('translate-x');
      const translateYElement = document.getElementById('translate-y');
      
      if (zoomElement) {
        zoomElement.textContent = transform.k.toFixed(2) + 'x';
      }
      if (translateXElement) {
        translateXElement.textContent = Math.round(transform.x);
      }
      if (translateYElement) {
        translateYElement.textContent = Math.round(transform.y);
      }
    }
    

    
    // Inicializar cuando la página esté lista
    document.addEventListener('DOMContentLoaded', initDiagram);
  </script>
</body>
</html>
