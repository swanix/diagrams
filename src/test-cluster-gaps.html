<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test: Gaps Uniformes entre Clusters</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
        }
        .test-info {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .test-info h2 {
            margin-top: 0;
            color: #4CAF50;
        }
        .test-info ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        .test-info li {
            margin: 5px 0;
        }
        #sw-diagram {
            width: 100%;
            height: 80vh;
            border: 2px solid #444;
            border-radius: 8px;
            background: #1a1a1a;
        }
        .status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        .gap-analysis {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="test-info">
        <h2>üß™ Test: Gaps Uniformes entre Clusters</h2>
        <p><strong>Objetivo:</strong> Verificar que los gaps entre clusters son exactamente 60px independientemente del ancho de cada cluster.</p>
        
        <h3>L√≥gica aplicada (espera carga completa):</h3>
        <ul>
            <li>‚úÖ Esperar a que todas las im√°genes se carguen completamente</li>
            <li>‚úÖ Empezar desde posici√≥n 0 (sin margen)</li>
            <li>‚úÖ Para cada cluster: sumar ancho del cluster anterior + 60px de gap</li>
            <li>‚úÖ Centrar cada cluster en su posici√≥n calculada</li>
            <li>‚úÖ Gap uniforme de 60px entre todos los clusters</li>
        </ul>
        
        <h3>Resultado esperado:</h3>
        <ul>
            <li>üîç Gap exacto de 60px entre cluster 0 y 1</li>
            <li>üîç Gap exacto de 60px entre cluster 1 y 2</li>
            <li>üîç Gap exacto de 60px entre cluster 2 y 3</li>
            <li>üîç Y as√≠ sucesivamente...</li>
        </ul>
    </div>

    <div class="status" id="status">Cargando...</div>

    <div id="sw-diagram"></div>

    <div class="gap-analysis" id="gapAnalysis"></div>

    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- PapaParse para CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    
    <!-- Swanix Diagrams -->
    <link rel="stylesheet" href="xdiagrams.css">
    <script src="xdiagrams.js"></script>
    <script src="xloader.js"></script>

    <script>
        // Configuraci√≥n de prueba con clusters de diferentes tama√±os
        window.$xDiagrams = {
            diagrams: [
                {
                    name: "Cluster Peque√±o",
                    url: "data/one-cluster.csv"
                },
                {
                    name: "Cluster Mediano", 
                    url: "data/multi-clusters.csv"
                },
                {
                    name: "Cluster Grande",
                    url: "data/multi-clusters-20.csv"
                },
                {
                    name: "Cluster Muy Grande",
                    url: "data/performance-test-300-nodes.json"
                },
                {
                    name: "Cluster Enorme",
                    url: "data/performance-test-800-nodes.json"
                }
            ],
            options: {
                theme: 'onyx',
                autoZoom: true,
                sidePanel: true,
                keyboardNavigation: true
            }
        };

        // Funci√≥n para actualizar el status
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // Funci√≥n para mostrar an√°lisis de gaps
        function showGapAnalysis() {
            const clusters = document.querySelectorAll('.cluster-rect');
            const analysisDiv = document.getElementById('gapAnalysis');
            let analysis = '<strong>An√°lisis de Gaps:</strong><br>';
            
            for (let i = 0; i < clusters.length - 1; i++) {
                const rect1 = clusters[i].getBoundingClientRect();
                const rect2 = clusters[i + 1].getBoundingClientRect();
                const actualGap = rect2.left - rect1.right;
                const expectedGap = 60;
                const gapDiff = Math.abs(actualGap - expectedGap);
                const status = gapDiff < 5 ? '‚úÖ' : '‚ùå';
                
                analysis += `${status} Gap ${i}‚Üí${i+1}: ${actualGap.toFixed(1)}px (esperado: ${expectedGap}px, diff: ${gapDiff.toFixed(1)}px)<br>`;
            }
            
            analysisDiv.innerHTML = analysis;
        }

        // Hook para detectar cuando se completa el layout
        window.$xDiagrams.hooks = {
            onLayoutComplete: function() {
                updateStatus('‚úÖ Layout completado - Analizando gaps...');
                
                setTimeout(() => {
                    showGapAnalysis();
                    
                    // Verificar gaps en consola tambi√©n
                    const clusters = document.querySelectorAll('.cluster-rect');
                    console.log('=== AN√ÅLISIS DE GAPS ===');
                    
                    for (let i = 0; i < clusters.length - 1; i++) {
                        const rect1 = clusters[i].getBoundingClientRect();
                        const rect2 = clusters[i + 1].getBoundingClientRect();
                        const actualGap = rect2.left - rect1.right;
                        const expectedGap = 60;
                        const gapDiff = Math.abs(actualGap - expectedGap);
                        const status = gapDiff < 5 ? '‚úÖ' : '‚ùå';
                        
                        console.log(`${status} Gap entre cluster ${i} y ${i+1}: ${actualGap.toFixed(1)}px (esperado: ${expectedGap}px, diff: ${gapDiff.toFixed(1)}px)`);
                        console.log(`  Cluster ${i}: ancho=${rect1.width.toFixed(1)}px, borde_der=${rect1.right.toFixed(1)}px`);
                        console.log(`  Cluster ${i+1}: ancho=${rect2.width.toFixed(1)}px, borde_izq=${rect2.left.toFixed(1)}px`);
                    }
                    
                    // Verificar que no hay superposiciones
                    let hasOverlap = false;
                    for (let i = 0; i < clusters.length; i++) {
                        for (let j = i + 1; j < clusters.length; j++) {
                            const rect1 = clusters[i].getBoundingClientRect();
                            const rect2 = clusters[j].getBoundingClientRect();
                            
                            if (!(rect1.right < rect2.left || 
                                  rect1.left > rect2.right || 
                                  rect1.bottom < rect2.top || 
                                  rect1.top > rect2.bottom)) {
                                hasOverlap = true;
                                console.warn(`‚ùå Superposici√≥n detectada entre clusters ${i} y ${j}`);
                            }
                        }
                    }
                    
                    if (!hasOverlap) {
                        updateStatus('‚úÖ Sin superposiciones - Gaps uniformes');
                    } else {
                        updateStatus('‚ùå Se detectaron superposiciones');
                    }
                }, 1000);
            }
        };

        // Inicializar cuando est√© listo
        document.addEventListener('DOMContentLoaded', function() {
            updateStatus('üîÑ Inicializando...');
            
            if (window.initializeWhenReady) {
                window.initializeWhenReady();
            }
        });
    </script>
</body>
</html> 