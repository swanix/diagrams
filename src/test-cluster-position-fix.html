<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test: Posici√≥n del Primer Cluster - Sin Margen Negativo</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
        }
        .test-info {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .test-info h2 {
            margin-top: 0;
            color: #4CAF50;
        }
        .test-info ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        .test-info li {
            margin: 5px 0;
        }
        #sw-diagram {
            width: 100%;
            height: 80vh;
            border: 2px solid #444;
            border-radius: 8px;
            background: #1a1a1a;
        }
        .status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        .position-analysis {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 11px;
        }
        .canvas-info {
            background: #333;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="test-info">
        <h2>üß™ Test: Posici√≥n del Primer Cluster - Sin Margen Negativo</h2>
        <p><strong>Objetivo:</strong> Verificar que el primer cluster empieza desde la posici√≥n correcta (marginX = 50px) sin margen negativo.</p>
        
        <h3>Cambios aplicados:</h3>
        <ul>
            <li>‚úÖ Layout: Solo el primer cluster empieza desde marginX (50px)</li>
            <li>‚úÖ Layout: Clusters subsiguientes empiezan inmediatamente despu√©s del anterior + 60px gap</li>
            <li>‚úÖ Zoom: Margen izquierdo consistente con el layout (50px en lugar de -150px)</li>
            <li>‚úÖ Gaps: Mantener 60px entre clusters</li>
            <li>‚úÖ Posici√≥n: Primer cluster visible desde el borde izquierdo del canvas</li>
        </ul>
        
        <h3>Resultado esperado:</h3>
        <ul>
            <li>üîç Primer cluster empieza a 50px del borde izquierdo del canvas</li>
            <li>üîç Clusters subsiguientes empiezan inmediatamente despu√©s del anterior + 60px gap</li>
            <li>üîç No hay margen negativo (cluster no se corta)</li>
            <li>üîç Gaps de 60px entre clusters mantenidos</li>
            <li>üîç Todos los clusters completamente visibles</li>
        </ul>
    </div>

    <div class="status" id="status">Cargando...</div>

    <div id="sw-diagram"></div>

    <div class="position-analysis" id="positionAnalysis"></div>
    <div class="canvas-info" id="canvasInfo"></div>

    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- PapaParse para CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    
    <!-- Swanix Diagrams -->
    <link rel="stylesheet" href="xdiagrams.css">
    <script src="xdiagrams.js"></script>
    <script src="xloader.js"></script>

    <script>
        // Configuraci√≥n de prueba con clusters de diferentes tama√±os
        window.$xDiagrams = {
            diagrams: [
                {
                    name: "Test: Clusters Diferentes Tama√±os",
                    url: "data/multi-clusters.csv"
                }
            ],
            options: {
                theme: 'onyx',
                autoZoom: true,
                sidePanel: true,
                keyboardNavigation: true
            }
        };

        // Funci√≥n para actualizar el status
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // Funci√≥n para mostrar an√°lisis de posiciones
        function showPositionAnalysis() {
            const clusters = document.querySelectorAll('.cluster-rect');
            const analysisDiv = document.getElementById('positionAnalysis');
            const canvasDiv = document.getElementById('canvasInfo');
            let analysis = '<strong>An√°lisis de Posiciones:</strong><br>';
            let canvasInfo = '<strong>Informaci√≥n del Canvas:</strong><br>';
            
            // Informaci√≥n del canvas
            const svg = document.getElementById('main-diagram-svg');
            const svgBounds = svg.getBoundingClientRect();
            canvasInfo += `Canvas: ancho=${svgBounds.width.toFixed(1)}px, alto=${svgBounds.height.toFixed(1)}px<br>`;
            canvasInfo += `Canvas borde izquierdo: ${svgBounds.left.toFixed(1)}px<br>`;
            
            if (clusters.length > 0) {
                const firstCluster = clusters[0];
                const firstRect = firstCluster.getBoundingClientRect();
                const distanceFromCanvas = firstRect.left - svgBounds.left;
                const expectedMargin = 50; // marginX
                const marginDiff = Math.abs(distanceFromCanvas - expectedMargin);
                const status = marginDiff < 10 ? '‚úÖ' : '‚ùå';
                
                analysis += `${status} Primer cluster: distancia desde canvas = ${distanceFromCanvas.toFixed(1)}px (esperado: ${expectedMargin}px, diff: ${marginDiff.toFixed(1)}px)<br>`;
                analysis += `  Primer cluster: ancho=${firstRect.width.toFixed(1)}px, borde_izq=${firstRect.left.toFixed(1)}px, borde_der=${firstRect.right.toFixed(1)}px<br>`;
                
                // Verificar que no hay margen negativo
                if (firstRect.left < svgBounds.left) {
                    analysis += `‚ùå ADVERTENCIA: Primer cluster tiene margen negativo (${(firstRect.left - svgBounds.left).toFixed(1)}px)<br>`;
                } else {
                    analysis += `‚úÖ Primer cluster sin margen negativo<br>`;
                }
                
                // Verificar que solo el primer cluster tiene margen
                if (clusters.length > 1) {
                    const secondCluster = clusters[1];
                    const secondRect = secondCluster.getBoundingClientRect();
                    const secondDistanceFromCanvas = secondRect.left - svgBounds.left;
                    const expectedSecondPosition = firstRect.right + 60; // primer cluster + gap
                    const secondDiff = Math.abs(secondDistanceFromCanvas - expectedSecondPosition);
                    const secondStatus = secondDiff < 10 ? '‚úÖ' : '‚ùå';
                    
                    analysis += `${secondStatus} Segundo cluster: empieza inmediatamente despu√©s del primero + gap (${secondDistanceFromCanvas.toFixed(1)}px vs esperado: ${expectedSecondPosition.toFixed(1)}px)<br>`;
                }
            }
            
            // Analizar gaps entre clusters
            for (let i = 0; i < clusters.length - 1; i++) {
                const rect1 = clusters[i].getBoundingClientRect();
                const rect2 = clusters[i + 1].getBoundingClientRect();
                const actualGap = rect2.left - rect1.right;
                const expectedGap = 60;
                const gapDiff = Math.abs(actualGap - expectedGap);
                const status = gapDiff < 5 ? '‚úÖ' : '‚ùå';
                
                analysis += `${status} Gap ${i}‚Üí${i+1}: ${actualGap.toFixed(1)}px (esperado: ${expectedGap}px, diff: ${gapDiff.toFixed(1)}px)<br>`;
            }
            
            // Verificar que todos los clusters est√°n completamente visibles
            let allVisible = true;
            clusters.forEach((cluster, index) => {
                const rect = cluster.getBoundingClientRect();
                if (rect.right > svgBounds.right) {
                    analysis += `‚ùå Cluster ${index}: se corta por la derecha (${(rect.right - svgBounds.right).toFixed(1)}px)<br>`;
                    allVisible = false;
                }
                if (rect.left < svgBounds.left) {
                    analysis += `‚ùå Cluster ${index}: se corta por la izquierda (${(svgBounds.left - rect.left).toFixed(1)}px)<br>`;
                    allVisible = false;
                }
            });
            
            if (allVisible) {
                analysis += `‚úÖ Todos los clusters completamente visibles<br>`;
            }
            
            analysisDiv.innerHTML = analysis;
            canvasDiv.innerHTML = canvasInfo;
        }

        // Hook para detectar cuando se completa el layout
        window.$xDiagrams.hooks = {
            onLayoutComplete: function() {
                updateStatus('‚úÖ Layout completado - Analizando posiciones...');
                
                setTimeout(() => {
                    showPositionAnalysis();
                    
                    // Verificar posiciones en consola tambi√©n
                    const clusters = document.querySelectorAll('.cluster-rect');
                    const svg = document.getElementById('main-diagram-svg');
                    const svgBounds = svg.getBoundingClientRect();
                    
                    console.log('=== AN√ÅLISIS DE POSICIONES ===');
                    console.log(`Canvas: ancho=${svgBounds.width.toFixed(1)}px, borde_izq=${svgBounds.left.toFixed(1)}px`);
                    
                    if (clusters.length > 0) {
                        const firstCluster = clusters[0];
                        const firstRect = firstCluster.getBoundingClientRect();
                        const distanceFromCanvas = firstRect.left - svgBounds.left;
                        const expectedMargin = 50;
                        const marginDiff = Math.abs(distanceFromCanvas - expectedMargin);
                        const status = marginDiff < 10 ? '‚úÖ' : '‚ùå';
                        
                        console.log(`${status} Primer cluster: distancia desde canvas = ${distanceFromCanvas.toFixed(1)}px (esperado: ${expectedMargin}px, diff: ${marginDiff.toFixed(1)}px)`);
                        console.log(`  Primer cluster: ancho=${firstRect.width.toFixed(1)}px, borde_izq=${firstRect.left.toFixed(1)}px, borde_der=${firstRect.right.toFixed(1)}px`);
                        
                        if (firstRect.left < svgBounds.left) {
                            console.warn(`‚ùå ADVERTENCIA: Primer cluster tiene margen negativo (${(firstRect.left - svgBounds.left).toFixed(1)}px)`);
                        } else {
                            console.log(`‚úÖ Primer cluster sin margen negativo`);
                        }
                        
                        // Verificar que solo el primer cluster tiene margen
                        if (clusters.length > 1) {
                            const secondCluster = clusters[1];
                            const secondRect = secondCluster.getBoundingClientRect();
                            const secondDistanceFromCanvas = secondRect.left - svgBounds.left;
                            const expectedSecondPosition = firstRect.right + 60; // primer cluster + gap
                            const secondDiff = Math.abs(secondDistanceFromCanvas - expectedSecondPosition);
                            const secondStatus = secondDiff < 10 ? '‚úÖ' : '‚ùå';
                            
                            console.log(`${secondStatus} Segundo cluster: empieza inmediatamente despu√©s del primero + gap (${secondDistanceFromCanvas.toFixed(1)}px vs esperado: ${expectedSecondPosition.toFixed(1)}px)`);
                        }
                    }
                    
                    // Verificar gaps
                    for (let i = 0; i < clusters.length - 1; i++) {
                        const rect1 = clusters[i].getBoundingClientRect();
                        const rect2 = clusters[i + 1].getBoundingClientRect();
                        const actualGap = rect2.left - rect1.right;
                        const expectedGap = 60;
                        const gapDiff = Math.abs(actualGap - expectedGap);
                        const status = gapDiff < 5 ? '‚úÖ' : '‚ùå';
                        
                        console.log(`${status} Gap entre cluster ${i} y ${i+1}: ${actualGap.toFixed(1)}px (esperado: ${expectedGap}px, diff: ${gapDiff.toFixed(1)}px)`);
                    }
                    
                    // Verificar visibilidad completa
                    let allVisible = true;
                    clusters.forEach((cluster, index) => {
                        const rect = cluster.getBoundingClientRect();
                        if (rect.right > svgBounds.right || rect.left < svgBounds.left) {
                            console.warn(`‚ùå Cluster ${index}: no completamente visible`);
                            allVisible = false;
                        }
                    });
                    
                    if (allVisible) {
                        console.log(`‚úÖ Todos los clusters completamente visibles`);
                        updateStatus('‚úÖ Posiciones correctas - Sin margen negativo');
                    } else {
                        updateStatus('‚ùå Algunos clusters no completamente visibles');
                    }
                }, 1000);
            }
        };

        // Inicializar cuando est√© listo
        document.addEventListener('DOMContentLoaded', function() {
            updateStatus('üîÑ Inicializando...');
            
            if (window.initializeWhenReady) {
                window.initializeWhenReady();
            }
        });
    </script>
</body>
</html> 