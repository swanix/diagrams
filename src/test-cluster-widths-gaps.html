<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test: C√°lculos de Anchos y Gaps entre Clusters</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
        }
        .test-info {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .test-info h2 {
            margin-top: 0;
            color: #4CAF50;
        }
        .test-info ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        .test-info li {
            margin: 5px 0;
        }
        #sw-diagram {
            width: 100%;
            height: 80vh;
            border: 2px solid #444;
            border-radius: 8px;
            background: #1a1a1a;
        }
        .status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        .width-analysis {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 11px;
        }
        .gap-analysis {
            background: #333;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="test-info">
        <h2>üß™ Test: C√°lculos de Anchos y Gaps entre Clusters</h2>
        <p><strong>Objetivo:</strong> Verificar que los c√°lculos de anchos horizontales y gaps entre clusters son correctos y no est√°n afectados por mediciones anteriores.</p>
        
        <h3>Problemas corregidos:</h3>
        <ul>
            <li>‚úÖ Limpieza de transformaciones antes de medir anchos</li>
            <li>‚úÖ Medici√≥n del ancho real usando el rect√°ngulo de fondo</li>
            <li>‚úÖ C√°lculo correcto de posiciones sin afectaci√≥n de transformaciones anteriores</li>
            <li>‚úÖ Verificaci√≥n de gaps uniformes de 60px entre clusters</li>
            <li>‚úÖ Solo el primer cluster tiene margen izquierdo de 50px</li>
        </ul>
        
        <h3>Resultado esperado:</h3>
        <ul>
            <li>üîç Anchos reales medidos correctamente sin transformaciones</li>
            <li>üîç Gaps exactos de 60px entre todos los clusters</li>
            <li>üîç Primer cluster empieza a 50px del borde izquierdo</li>
            <li>üîç Clusters subsiguientes empiezan inmediatamente despu√©s del anterior + gap</li>
            <li>üîç Sin afectaci√≥n por mediciones o transformaciones anteriores</li>
        </ul>
    </div>

    <div class="status" id="status">Cargando...</div>

    <div id="sw-diagram"></div>

    <div class="width-analysis" id="widthAnalysis"></div>
    <div class="gap-analysis" id="gapAnalysis"></div>

    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- PapaParse para CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    
    <!-- Swanix Diagrams -->
    <link rel="stylesheet" href="xdiagrams.css">
    <script src="xdiagrams.js"></script>
    <script src="xloader.js"></script>

    <script>
        // Configuraci√≥n de prueba con clusters de diferentes tama√±os
        window.$xDiagrams = {
            diagrams: [
                {
                    name: "Test: Anchos y Gaps",
                    url: "data/multi-clusters.csv"
                }
            ],
            options: {
                theme: 'onyx',
                autoZoom: true,
                sidePanel: true,
                keyboardNavigation: true
            }
        };

        // Funci√≥n para actualizar el status
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // Funci√≥n para mostrar an√°lisis de anchos
        function showWidthAnalysis() {
            const clusters = document.querySelectorAll('.cluster-rect');
            const analysisDiv = document.getElementById('widthAnalysis');
            let analysis = '<strong>An√°lisis de Anchos Reales:</strong><br>';
            
            clusters.forEach((cluster, index) => {
                const rect = cluster.getBoundingClientRect();
                const computedStyle = window.getComputedStyle(cluster);
                const width = rect.width;
                const height = rect.height;
                
                analysis += `Cluster ${index}: ancho=${width.toFixed(1)}px, alto=${height.toFixed(1)}px<br>`;
                analysis += `  Borde izquierdo: ${rect.left.toFixed(1)}px<br>`;
                analysis += `  Borde derecho: ${rect.right.toFixed(1)}px<br>`;
                analysis += `  Centro: ${(rect.left + width/2).toFixed(1)}px<br>`;
            });
            
            analysisDiv.innerHTML = analysis;
        }

        // Funci√≥n para mostrar an√°lisis de gaps
        function showGapAnalysis() {
            const clusters = document.querySelectorAll('.cluster-rect');
            const analysisDiv = document.getElementById('gapAnalysis');
            let analysis = '<strong>An√°lisis de Gaps entre Clusters:</strong><br>';
            
            // Verificar gaps entre clusters consecutivos
            for (let i = 0; i < clusters.length - 1; i++) {
                const rect1 = clusters[i].getBoundingClientRect();
                const rect2 = clusters[i + 1].getBoundingClientRect();
                const actualGap = rect2.left - rect1.right;
                const expectedGap = 60;
                const gapDiff = Math.abs(actualGap - expectedGap);
                const status = gapDiff < 5 ? '‚úÖ' : '‚ùå';
                
                analysis += `${status} Gap ${i}‚Üí${i+1}: ${actualGap.toFixed(1)}px (esperado: ${expectedGap}px, diff: ${gapDiff.toFixed(1)}px)<br>`;
                analysis += `  Cluster ${i}: borde_der=${rect1.right.toFixed(1)}px<br>`;
                analysis += `  Cluster ${i+1}: borde_izq=${rect2.left.toFixed(1)}px<br>`;
            }
            
            // Verificar posici√≥n del primer cluster
            if (clusters.length > 0) {
                const firstCluster = clusters[0];
                const firstRect = firstCluster.getBoundingClientRect();
                const svg = document.getElementById('main-diagram-svg');
                const svgBounds = svg.getBoundingClientRect();
                const distanceFromCanvas = firstRect.left - svgBounds.left;
                const expectedMargin = 50;
                const marginDiff = Math.abs(distanceFromCanvas - expectedMargin);
                const status = marginDiff < 10 ? '‚úÖ' : '‚ùå';
                
                analysis += `<br><strong>Posici√≥n del Primer Cluster:</strong><br>`;
                analysis += `${status} Distancia desde canvas: ${distanceFromCanvas.toFixed(1)}px (esperado: ${expectedMargin}px, diff: ${marginDiff.toFixed(1)}px)<br>`;
            }
            
            analysisDiv.innerHTML = analysis;
        }

        // Hook para detectar cuando se completa el layout
        window.$xDiagrams.hooks = {
            onLayoutComplete: function() {
                updateStatus('‚úÖ Layout completado - Analizando anchos y gaps...');
                
                setTimeout(() => {
                    showWidthAnalysis();
                    showGapAnalysis();
                    
                    // Verificar en consola tambi√©n
                    const clusters = document.querySelectorAll('.cluster-rect');
                    const svg = document.getElementById('main-diagram-svg');
                    const svgBounds = svg.getBoundingClientRect();
                    
                    console.log('=== AN√ÅLISIS DE ANCHOS Y GAPS ===');
                    console.log(`Canvas: ancho=${svgBounds.width.toFixed(1)}px, borde_izq=${svgBounds.left.toFixed(1)}px`);
                    
                    // An√°lisis de anchos
                    clusters.forEach((cluster, index) => {
                        const rect = cluster.getBoundingClientRect();
                        console.log(`Cluster ${index}: ancho=${rect.width.toFixed(1)}px, alto=${rect.height.toFixed(1)}px`);
                        console.log(`  Borde izquierdo: ${rect.left.toFixed(1)}px, Borde derecho: ${rect.right.toFixed(1)}px`);
                    });
                    
                    // An√°lisis de gaps
                    console.log('\n=== AN√ÅLISIS DE GAPS ===');
                    for (let i = 0; i < clusters.length - 1; i++) {
                        const rect1 = clusters[i].getBoundingClientRect();
                        const rect2 = clusters[i + 1].getBoundingClientRect();
                        const actualGap = rect2.left - rect1.right;
                        const expectedGap = 60;
                        const gapDiff = Math.abs(actualGap - expectedGap);
                        const status = gapDiff < 5 ? '‚úÖ' : '‚ùå';
                        
                        console.log(`${status} Gap entre cluster ${i} y ${i+1}: ${actualGap.toFixed(1)}px (esperado: ${expectedGap}px, diff: ${gapDiff.toFixed(1)}px)`);
                    }
                    
                    // Verificar posici√≥n del primer cluster
                    if (clusters.length > 0) {
                        const firstCluster = clusters[0];
                        const firstRect = firstCluster.getBoundingClientRect();
                        const distanceFromCanvas = firstRect.left - svgBounds.left;
                        const expectedMargin = 50;
                        const marginDiff = Math.abs(distanceFromCanvas - expectedMargin);
                        const status = marginDiff < 10 ? '‚úÖ' : '‚ùå';
                        
                        console.log(`\n${status} Primer cluster: distancia desde canvas = ${distanceFromCanvas.toFixed(1)}px (esperado: ${expectedMargin}px, diff: ${marginDiff.toFixed(1)}px)`);
                    }
                    
                    // Verificar que no hay superposiciones
                    let hasOverlap = false;
                    for (let i = 0; i < clusters.length; i++) {
                        for (let j = i + 1; j < clusters.length; j++) {
                            const rect1 = clusters[i].getBoundingClientRect();
                            const rect2 = clusters[j].getBoundingClientRect();
                            
                            if (!(rect1.right < rect2.left || 
                                  rect1.left > rect2.right || 
                                  rect1.bottom < rect2.top || 
                                  rect1.top > rect2.bottom)) {
                                hasOverlap = true;
                                console.warn(`‚ùå Superposici√≥n detectada entre clusters ${i} y ${j}`);
                            }
                        }
                    }
                    
                    if (!hasOverlap) {
                        console.log('‚úÖ Sin superposiciones - Layout correcto');
                        updateStatus('‚úÖ Anchos y gaps correctos - Sin superposiciones');
                    } else {
                        updateStatus('‚ùå Se detectaron superposiciones');
                    }
                }, 1000);
            }
        };

        // Inicializar cuando est√© listo
        document.addEventListener('DOMContentLoaded', function() {
            updateStatus('üîÑ Inicializando...');
            
            if (window.initializeWhenReady) {
                window.initializeWhenReady();
            }
        });
    </script>
</body>
</html> 