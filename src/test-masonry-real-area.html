<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Masonry con √Årea Real</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
        }
        .test-info {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .test-info h2 {
            margin-top: 0;
            color: #4CAF50;
        }
        .test-info ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        .test-info li {
            margin: 5px 0;
        }
        #sw-diagram {
            width: 100%;
            height: 80vh;
            border: 2px solid #444;
            border-radius: 8px;
            background: #1a1a1a;
        }
        .status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="test-info">
        <h2>üß™ Test: Masonry con √Årea Real</h2>
        <p><strong>Objetivo:</strong> Verificar que la nueva l√≥gica de masonry calcula correctamente las posiciones bas√°ndose en el √°rea real de cada cluster.</p>
        
        <h3>Cambios implementados:</h3>
        <ul>
            <li>‚úÖ Se aplican los fondos de todos los clusters primero</li>
            <li>‚úÖ Se espera un frame para que se rendericen los fondos</li>
            <li>‚úÖ Se mide el √°rea real de cada cluster con getBBox()</li>
            <li>‚úÖ Se calcula altura uniforme por fila (cluster m√°s alto)</li>
            <li>‚úÖ Se calcula ancho total de cada fila (clusters + gaps)</li>
            <li>‚úÖ Se posicionan clusters con gap uniforme entre ellos</li>
            <li>‚úÖ Se evita la superposici√≥n de clusters</li>
        </ul>
        
        <h3>Resultado esperado:</h3>
        <ul>
            <li>üîç Los clusters no deben superponerse</li>
            <li>üîç Deben estar alineados a la izquierda</li>
            <li>üîç M√°ximo 7 clusters por fila</li>
            <li>üîç Altura uniforme por fila (basada en el cluster m√°s alto)</li>
            <li>üîç Gap uniforme entre clusters (60px)</li>
            <li>üîç Espaciado correcto entre filas</li>
        </ul>
    </div>

    <div class="status" id="status">Cargando...</div>

    <div id="sw-diagram"></div>

    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- PapaParse para CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    
    <!-- Swanix Diagrams -->
    <link rel="stylesheet" href="xdiagrams.css">
    <script src="xdiagrams.js"></script>
    <script src="xloader.js"></script>

    <script>
        // Configuraci√≥n de prueba
        window.$xDiagrams = {
            diagrams: [
                {
                    name: "Test Cluster 1",
                    url: "data/multi-clusters.csv"
                },
                {
                    name: "Test Cluster 2", 
                    url: "data/multi-clusters-20.csv"
                },
                {
                    name: "Test Cluster 3",
                    url: "data/one-cluster.csv"
                },
                {
                    name: "Test Cluster 4",
                    url: "data/flat-list-example.csv"
                },
                {
                    name: "Test Cluster 5",
                    url: "data/site.csv"
                },
                {
                    name: "Test Cluster 6",
                    url: "data/characters.json"
                },
                {
                    name: "Test Cluster 7",
                    url: "data/flat-list-simple.csv"
                },
                {
                    name: "Test Cluster 8",
                    url: "data/performance-test-300-nodes.json"
                },
                {
                    name: "Test Cluster 9",
                    url: "data/performance-test-800-nodes.json"
                },
                {
                    name: "Test Cluster 10",
                    url: "data/flat-1000-nodes.json"
                }
            ],
            options: {
                theme: 'onyx',
                autoZoom: true,
                sidePanel: true,
                keyboardNavigation: true
            }
        };

        // Funci√≥n para actualizar el status
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // Hook para detectar cuando se completa el layout
        window.$xDiagrams.hooks = {
            onLayoutComplete: function() {
                updateStatus('‚úÖ Layout completado con altura uniforme por fila');
                
                // Verificar que no hay superposiciones y mostrar informaci√≥n de filas
                setTimeout(() => {
                    const clusters = document.querySelectorAll('.cluster-rect');
                    let hasOverlap = false;
                    
                    // Obtener informaci√≥n del canvas
                    const svgElement = document.getElementById("main-diagram-svg");
                    const svgBounds = svgElement ? svgElement.getBoundingClientRect() : null;
                    console.log(`Canvas SVG: left=${svgBounds?.left.toFixed(1)}px, width=${svgBounds?.width.toFixed(1)}px`);
                    
                    // Agrupar clusters por filas para an√°lisis
                    const clustersPerRow = 7;
                    const totalRows = Math.ceil(clusters.length / clustersPerRow);
                    const rowInfo = [];
                    
                    for (let row = 0; row < totalRows; row++) {
                        const startIndex = row * clustersPerRow;
                        const endIndex = Math.min(startIndex + clustersPerRow, clusters.length);
                        const rowClusters = Array.from(clusters).slice(startIndex, endIndex);
                        
                        const heights = rowClusters.map(cluster => {
                            const rect = cluster.getBoundingClientRect();
                            return rect.height;
                        });
                        
                        const maxHeight = Math.max(...heights);
                        const avgHeight = heights.reduce((a, b) => a + b, 0) / heights.length;
                        
                        rowInfo.push({
                            row: row,
                            clusterCount: rowClusters.length,
                            maxHeight: maxHeight,
                            avgHeight: avgHeight,
                            heights: heights
                        });
                        
                        console.log(`Fila ${row}: ${rowClusters.length} clusters, altura m√°xima: ${maxHeight.toFixed(1)}px, altura promedio: ${avgHeight.toFixed(1)}px`);
                        
                        // Analizar espaciado horizontal
                        const widths = rowClusters.map(cluster => {
                            const rect = cluster.getBoundingClientRect();
                            return rect.width;
                        });
                        
                        const totalWidth = widths.reduce((a, b) => a + b, 0);
                        const expectedGaps = (rowClusters.length - 1) * 60; // 60px es el spacingX
                        const totalExpectedWidth = totalWidth + expectedGaps;
                        
                        console.log(`  Ancho total: ${totalWidth.toFixed(1)}px, gaps esperados: ${expectedGaps}px, ancho total esperado: ${totalExpectedWidth.toFixed(1)}px`);
                        
                        // Verificar posici√≥n del primer cluster
                        if (rowClusters.length > 0) {
                            const firstCluster = rowClusters[0];
                            const firstRect = firstCluster.getBoundingClientRect();
                            const distanceFromCanvas = firstRect.left - (svgBounds?.left || 0);
                            console.log(`  Primer cluster: distancia desde borde del canvas = ${distanceFromCanvas.toFixed(1)}px (esperado: ~0px)`);
                        }
                        
                        // Verificar espaciado entre clusters
                        for (let i = 0; i < rowClusters.length - 1; i++) {
                            const rect1 = rowClusters[i].getBoundingClientRect();
                            const rect2 = rowClusters[i + 1].getBoundingClientRect();
                            const actualGap = rect2.left - rect1.right;
                            const expectedGap = 60;
                            const gapDiff = Math.abs(actualGap - expectedGap);
                            const status = gapDiff < 5 ? '‚úÖ' : '‚ùå';
                            console.log(`${status} Gap entre cluster ${i} y ${i+1}: ${actualGap.toFixed(1)}px (esperado: ${expectedGap}px, diff: ${gapDiff.toFixed(1)}px)`);
                        }
                    }
                    
                    // Verificar superposiciones
                    for (let i = 0; i < clusters.length; i++) {
                        for (let j = i + 1; j < clusters.length; j++) {
                            const rect1 = clusters[i].getBoundingClientRect();
                            const rect2 = clusters[j].getBoundingClientRect();
                            
                            if (!(rect1.right < rect2.left || 
                                  rect1.left > rect2.right || 
                                  rect1.bottom < rect2.top || 
                                  rect1.top > rect2.bottom)) {
                                hasOverlap = true;
                                console.warn(`Superposici√≥n detectada entre clusters ${i} y ${j}`);
                            }
                        }
                    }
                    
                    if (!hasOverlap) {
                        updateStatus(`‚úÖ Sin superposiciones - ${totalRows} filas analizadas`);
                    } else {
                        updateStatus('‚ùå Se detectaron superposiciones');
                    }
                }, 1000);
            }
        };

        // Inicializar cuando est√© listo
        document.addEventListener('DOMContentLoaded', function() {
            updateStatus('üîÑ Inicializando...');
            
            if (window.initializeWhenReady) {
                window.initializeWhenReady();
            }
        });
    </script>
</body>
</html> 